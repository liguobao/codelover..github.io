<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>codelover&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一直走在吃软饭路上的软狗">
<meta property="og:type" content="website">
<meta property="og:title" content="codelover's blog">
<meta property="og:url" content="http://codelover.link/index.html">
<meta property="og:site_name" content="codelover's blog">
<meta property="og:description" content="一直走在吃软饭路上的软狗">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="codelover's blog">
<meta name="twitter:description" content="一直走在吃软饭路上的软狗">
  
    <link rel="alternative" href="/atom.xml" title="codelover&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">codelover&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://codelover.link"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ubuntu使用jexus搭建mywebsql" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/06/ubuntu使用jexus搭建mywebsql/" class="article-date">
  <time datetime="2016-03-06T10:57:35.423Z" itemprop="datePublished">2016-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ubuntu/">ubuntu</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/06/ubuntu使用jexus搭建mywebsql/">ubuntu使用Jexus搭建MyWebSQL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前在阿里云上装了一个ubuntu，后来也没怎么用力，就挂这一个mysql数据库。最近在家里用MySQL Workbench 连接阿里云上面的MySQL的时候，连着过了一会就中断了。后来看了一圈回来才发现，目测是家里电信宽带的锅，不断给我动态分配IP地址….后来群里面的小伙伴说，搭个websql了事啦。听起来不错的想法，于是昨天就试了一下。</p>
<p>之前在ubuntu上装过apache，后来为了跑asp.net，把apache停了，换成了jexus。<br>Jexus是国内.NET 跨平台大牛们写的一个web服务器，使用方便，很稳定，也在不断加入新特性。相关资料直接访问<a href="http://www.jexus.org/" target="_blank" rel="external">www.jexus.org</a>。</p>
<p>jexus是以mono为基础的，其实首先应该先配置mono的运行环境。</p>
<p>###第一步 安装mono<br>相关资料链接：</p>
<p><a href="http://www.linuxdot.net/bbsfile-3090" target="_blank" rel="external">在Ubuntu操作系统上安装mono的具体方法</a></p>
<p><a href="http://www.isvee.com/archives/763" target="_blank" rel="external">Ubuntu 14.04 安装 Mono</a></p>
<p>我的ubuntu老早之前就安装好了mono，这个就此瞥过咯。</p>
<p>###第二步 安装jexus</p>
<p><a href="http://www.linuxdot.net/bbsfile-3084" target="_blank" rel="external">Jexus web server V5.1 安装配置要点</a></p>
<p><a href="http://www.jexus.org/" target="_blank" rel="external">jexus首页</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A、安装：</span><br><span class="line">cd /tmp</span><br><span class="line">wget linuxdot.net/down/jexus-<span class="number">5.8</span><span class="number">.1</span>.tar.gz </span><br><span class="line">tar -zxvf jexus-<span class="number">5.8</span><span class="number">.1</span>.tar.gz </span><br><span class="line">cd jexus-<span class="number">5.8</span><span class="number">.1</span> </span><br><span class="line">sudo ./install </span><br><span class="line"></span><br><span class="line">B、更新</span><br><span class="line">cd /tmp</span><br><span class="line">sudo /usr/jexus/jws stop</span><br><span class="line">wget linuxdot.net/down/jexus-<span class="number">5.8</span><span class="number">.1</span>.tar.gz</span><br><span class="line">tar -zxvf jexus-<span class="number">5.8</span><span class="number">.1</span>.tar.gz</span><br><span class="line">cd jexus-<span class="number">5.8</span><span class="number">.1</span></span><br><span class="line">sudo ./upgrade</span><br></pre></td></tr></table></figure>
<p>5.8.1差不多是现在最新版本了。</p>
<p>###第三步 jexus 支持PHP</p>
<p>先在ubuntu上安装一下PHP5-CGI.</p>
<p><a href="http://www.linuxidc.com/Linux/2012-05/60172.htm" target="_blank" rel="external">用 Jexus ASP.NET WEB服务器搭建 PHP 网站的具体方法</a></p>
<p>总结来说就是下面两句：<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line"></span><br><span class="line">sudo apt-<span class="built_in">get</span> install php5-cgi</span><br></pre></td></tr></table></figure></p>
<p>接着：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)修改“/etc/php.ini”文件:</span><br><span class="line"></span><br><span class="line">找到cgi.force_redirect=<span class="number">1</span>一行，把前边的<span class="string">"#"</span>号去掉，把值从<span class="number">1</span>改为<span class="number">0</span>，如：</span><br><span class="line"></span><br><span class="line">cgi.force_redirect=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)修改jws.conf。打开jexus文件夹中的jws.conf，作如下配置：</span><br><span class="line"></span><br><span class="line">填写PHP-CGI程序路径和工作进程数。如：“php-fcgi.<span class="built_in">set</span>=/usr/bin/php-cgi,<span class="number">6</span>”。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)修改网站配置。在需要使用PHP的网站的配置文件中添加:</span><br><span class="line"></span><br><span class="line">fastcgi.add=php|socket:/var/run/jexus/phpsvr</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/shanyou/p/3369322.html" target="_blank" rel="external">Jexus 支持PHP的三种方式-张善友</a></p>
<p>搞完上面这些，理论上你的jexus已经能跑PHP网站了。</p>
<p>###第四步 安装mywebsql</p>
<p><a href="http://mywebsql.net/" target="_blank" rel="external">mywebsql首页</a></p>
<p>mywebsql跑起来应该是下图的：</p>
<p><img src="http://7xread.com1.z0.glb.clouddn.com/7d902b94-f132-4041-84fa-78f044f91358" alt="mywebsql效果图"></p>
<p><a href="https://sourceforge.net/projects/mywebsql/files/stable/mywebsql-3.6.zip/download" target="_blank" rel="external">下载地址</a></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /tmp</span><br><span class="line"></span><br><span class="line">wget https:<span class="comment">//sourceforge.net/projects/mywebsql/files/stable/mywebsql-3.6.zip</span></span><br><span class="line"></span><br><span class="line">cp mywebsql-3.6.<span class="keyword">zip</span> /<span class="keyword">var</span>/www </span><br><span class="line"></span><br><span class="line"><span class="keyword">cd</span> /<span class="keyword">var</span>/www</span><br><span class="line"></span><br><span class="line">tar -zxvf mywebsql-3.6.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure>
<p>把mywebsql网站文件弄好之后，就可以去看jexus配置php网站了。</p>
<p>jexus的网站配置文件夹一般路径就是/usr/jexus/siteconf/</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/jexus/siteconf/</span><br><span class="line"></span><br><span class="line">vi mywebSQL <span class="comment">#创建网站配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .. </span><br><span class="line"></span><br><span class="line">./jexus restart</span><br></pre></td></tr></table></figure>
<p>上面的mywebSQL里面就写网站配置了，主要是端口号/运行环境之类的配置。</p>
<p>贴一下我的配置：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#仅供参考</span></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">####</span><br><span class="line"># Web Site: Default</span><br><span class="line">###</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">port=<span class="number">2016</span></span><br><span class="line">root=/ /var/www/mywebsql</span><br><span class="line">hosts=*    <span class="comment">#OR your.com,*.your.com</span></span><br><span class="line">usephp =<span class="literal">true</span></span><br><span class="line">fastcgi.add=php|<span class="attribute">socket</span>:/var/run/jexus/phpsvr</span><br><span class="line"></span><br><span class="line"><span class="comment"># addr=0.0.0.0</span></span><br><span class="line"><span class="comment"># CheckQuery=false</span></span><br><span class="line"><span class="comment"># NoLog=true</span></span><br><span class="line"><span class="comment"># NoFile=/index.aspx</span></span><br><span class="line"><span class="comment"># Keep_Alive=false</span></span><br><span class="line"><span class="comment"># UseGZIP=true</span></span><br><span class="line"><span class="comment"># UseHttps=true</span></span><br><span class="line"><span class="comment"># DenyFrom=192.168.0.233, 192.168.1.*, 192.168.2.0/24</span></span><br><span class="line"><span class="comment"># AllowFrom=192.168.*.*</span></span><br><span class="line"><span class="comment"># DenyDirs=~/cgi, ~/upfiles</span></span><br><span class="line"><span class="comment"># indexes=myindex.aspx</span></span><br><span class="line"><span class="comment"># rewrite=^/.+?\.(asp|php|cgi|pl|sh)$ /index.aspx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reproxy=/bbs/ http://192.168.1.112/bbs/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Jexus php fastcgi address is '/var/run/jexus/phpsvr'</span></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"><span class="comment"># fastcgi.add=php|socket:/var/run/jexus/phpsvr</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># php-fpm listen address is '127.0.0.1:9000'</span></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">##</span></span><br><span class="line"><span class="comment"># fastcgi.add=php|tcp:127.0.0.1:9000</span></span><br></pre></td></tr></table></figure>
<p>到这里，访问<a href="http://你的主机IP:上面配置的端口号" target="_blank" rel="external">http://你的主机IP:上面配置的端口号</a> 就能看到下面的页面了。</p>
<p><img src="http://7xread.com1.z0.glb.clouddn.com/df3951c0-9d3d-4085-b577-743df68c1d98" alt="MywWebSQL登陆页"></p>
<p>输入账号密码就能登陆。</p>
<p>###然而….<br>我登陆的时候显示，系统提示：没有安装客户端库。</p>
<p>###第五步 配置PHP MySQL库</p>
<p>于是又跑去看了一下MyWebSQL的说明，文档上说可以在/install.php上面看配置。</p>
<p><img src="http://7xread.com1.z0.glb.clouddn.com/cf8d88d8-fb5d-42f0-81cc-e0fbb566ebe5" alt="这是配置好的效果图"></p>
<p>显示：</p>
<p>MySQL Client Library    client library is not installed<br>MySQL improved functionality    client library is not installed</p>
<p>好吧，PHP MySQL客户端库没有安装….</p>
<p>那就安装咯。<br>于是找到了下面一个文章：<br><a href="http://www.cnblogs.com/CheeseZH/p/4694135.html" target="_blank" rel="external">ZH奶酪：Ubuntu 14.04安装LAMP(Linux，Apache，MySQL，PHP)</a></p>
<p>安装一下基础库<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install php5 libapache2-<span class="keyword">mod</span>-php5 php5-mcrypt php5-curl php5-imagick php5-cli</span><br></pre></td></tr></table></figure></p>
<p>搜索一下还有什么库可以安装。</p>
<p>apt-cache search php5-</p>
<p><img src="http://7xread.com1.z0.glb.clouddn.com/7bac43bc-01ea-4ce0-ba4b-37a06a51fe3a" alt=""></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> php5 php5-mysqlnd </span><br><span class="line"></span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> php5 php5-mysqlnd-ms</span></span><br></pre></td></tr></table></figure>
<p>接着重启一下jexus的网站，万事大吉。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/03/06/ubuntu使用jexus搭建mywebsql/" data-id="cilgg02as000fs0unrihbkxfe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Bytes -To-String" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/03/Bytes -To-String/" class="article-date">
  <time datetime="2016-03-03T15:19:50.488Z" itemprop="datePublished">2016-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/net/">.net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/03/Bytes -To-String/">bytes to string</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有时候我们会遇到需要把数据加密之后再网络上传输的需求，这样的话一般使用AES256之类的算法，经过运算之后得到一个byte数组，接着转换成string，就扔出去了。对方拿到之后，用密钥解密之后便得到了对应的数据。</p>
<p>在C#里面，Byte数组转String字符串我们一般用Convert.ToBase64()完成。</p>
<p>代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">BytesToString</span>(<span class="params"><span class="keyword">byte</span>[] buff</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Convert.ToBase64String(buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] StringToBytes(<span class="keyword">string</span> input)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Encoding.UTF8.GetBytes(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 一般来说这样也没撒问题了，不过，如果这个数据是通过URL的方式给出去的，这时候就要考虑一下特殊字符编码问题了。+、空格、%之类的特殊字符可能会导致切断URL传参的数据，导致得到的数据不一致。这样的话，解密也做不下去了。</p>
<p> 相关资料：<br> <br>1、<a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="external">关于URL编码</a><br> <br>2、<a href="http://blog.csdn.net/luo_deng/article/details/12186535" target="_blank" rel="external">URL编码—-url参数中有+、空格、=、%、&amp;、#等特殊符号的问题解决</a></p>
<p> 不过也好在，C#提供了一个HttpUtility.UrlEncode(input)和HttpUtility.UrlEncode(input)这两个函数，让我们直接把上面的特殊字符转换成URL可识别的转义字符。<br> 数据出去之后先Encode一下，回来之后Decode一下，好像问题都解决了吧。</p>
<p>然而我们都忘了一件事情，URL到了浏览器之后，自然会对URL里面的东西Decode一次。<br>我实现的时候，在后台验证的时候又Decode一次,这就出问题了。</p>
<p>问题在哪呢？一个encode的字符被decode两次，内容已经被改掉了…<br>这就导致解密的时候直接挂了….</p>
<p>这样看来，<br>Convert.ToBase64String()这个不够靠谱，出来的数据可能会有特殊字符的问题。<br>怎么解决呢？那天晚上和老大/CTO都在看这个bug。一下子都没撒好办法….</p>
<p>后来CTO想了一下，说byte不就是最大不久255么？直接转16进制字符就是嘛。<br>于是有了下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> byte数组转string</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="bytes"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">BytesToString</span>(<span class="params"><span class="keyword">byte</span>[] bytes</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bytes == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">string</span>.Empty;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">string</span>.Join(<span class="keyword">string</span>.Empty, </span><br><span class="line">   bytes.Select(b =&gt; <span class="keyword">string</span>.Format(<span class="string">"&#123;0:x2&#125;"</span>, b)).ToArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> string转byte数组</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="str"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] StringToBytes(<span class="keyword">string</span> str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(str))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[str.Length / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.Length; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes[i / <span class="number">2</span>] = Convert.ToByte(<span class="string">"0x"</span> + str[i] + str[i + <span class="number">1</span>], <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题解决。</p>
<p>关于base64的实现，下面这个链接是相关资料，有兴趣自己看啦。</p>
<p><a href="http://www.hejingzong.cn/blog/ViewBlog_36.aspx" target="_blank" rel="external">C#/ASP.NET Base64编码原理及实现</a></p>
<p><a href="http://www.cnblogs.com/tuyile006/archive/2008/01/17/1043178.html" target="_blank" rel="external">C＃实现Base64编码与解码</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/03/03/Bytes -To-String/" data-id="cilgg02920000s0unai9yhlhw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-技巧避免修改绑定变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/01/技巧避免修改绑定变量/" class="article-date">
  <time datetime="2016-03-01T12:49:34.588Z" itemprop="datePublished">2016-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/net/">.net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/技巧避免修改绑定变量/">.NET-lmabda避免修改绑定变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先看一段代码</p>
<pre><code>#region test1 闭包

public static void test1()
{
    int index = 0;
    Func&lt;IEnumerable&lt;int&gt;&gt; sequence =()=&gt;GetEnumrableInt(index);

    index = 20;
    foreach(int n in sequence())
        Console.WriteLine(n);

    Console.WriteLine(&quot;Done&quot;);

    index = 100;
    foreach (int n in sequence())
        Console.WriteLine(n);
}


public static IEnumerable&lt;int&gt; GetEnumrableInt(int index)
{
    List&lt;int&gt; l = new List&lt;int&gt;();
    for(int i=index;i&lt;index+30;i++)
    {
        l.Add(i);
    }
    return l;
}

#endregion
</code></pre><p>上面一坨代码演示了在闭包中使用了外部变量，随即又在外部修改了这些变量的情况，得到的结果是输出了20-50的数，然后又输出了100-130之间的数。这种行为有点诡异，但是确实有存在的意义…(书本这样说的，我到觉得很少会用到。)</p>
<p>为了将查询表达式转换成可执行代码，C#编译器做了很多工作。一般而言，C#编译器将查询和lambda表达式转换成 “静态委托”、”实例委托” 或 “闭包”。编译器将根据lambda表达式中的代码选择一种实现方式。选择哪种方式依赖于lambda表达式的主体（body）。这看上去似乎是一些语言上的实现细节，但它却会显著地影响到我们的代码。编译器选择何种实现将可能导致diamante行为发生微妙的变化。</p>
<p>并不是任何的lambda表达式都会生成同样结构的代码。</p>
<p>对于编译器来说，最简单的一种行为是为以下形式的代码生成委托。  </p>
<pre><code>//我们的lambda表达式
public static void test2()
{
    int[] someNum = {0,1,2,3,4,5,6,7,8,9,10 };

    IEnumerable&lt;int&gt; ans = from n in someNum
                           select n * n;

    foreach (int i in ans)
        Console.WriteLine(i);

}
</code></pre><p>编译器将使用静态委托来实现n*n的lambda表达式，其为上面代码生成的代码如下：</p>
<pre><code> //编译器为我们的lambda生成的代码
#region 等价于 test2()
private static int HiddenFunc(int n)
{
    return n * n;
}

//静态委托
private static Func&lt;int, int&gt; HiddenDelegate;

public void test2_1()
{

    int[] someNum = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    if(HiddenDelegate==null)
    {
        HiddenDelegate = new Func&lt;int, int&gt;(HiddenFunc);
    }
    IEnumerable&lt;int&gt; ans = someNum.Select&lt;int, int&gt;(HiddenDelegate);

  foreach(int i in ans)
      Console.WriteLine(i);

}
#endregion
</code></pre><p>这个lambda表达式主体部分并没有访问任何的实例变量或者局部变量。lambda表达式仅仅访问了它的参数。对于这种情况，C#编译器将创建一个静态方法，作为委托的目标。这也是编译器执行的最简单的一种处理方式。若表达式可以通过私有的静态方法实现，那么编译器将生成该私有的静态方法以及相对应的委托定义。对于上面的代码例子中的情况以及仅访问了静态变量的表达式，编译器都会采用这样的方案。</p>
<p>接下来介绍另一种较为简单的情况：<br>lambda表达式需要访问类型的实例变量，但无需访问外层方法中的局部变量。</p>
<pre><code>public class ModFilter
{
    private readonly int modules;

    public ModFilter(int mod)
    {
        modules = mod;
    }


    public IEnumerable&lt;int&gt; FindValues(IEnumerable&lt;int&gt; sequence)
    {

        return from n in sequence
               where n % modules == 0 //新添加的表达式
               select n * n;  //和前面的例子是一样的
    }
}
</code></pre><p>/* </p>
<p>在这种情况下，编译器将为表达式创建一个实例方法来包装该委托。<br>其基本概念和前一种情况一致，只是这里使用了实例方法，以便读取并修改当前对象的状态。<br>与静态委托的例子一样，这里编译器将把lambda表达式转换成我们熟悉的代码。其中包含委托的定义以及方法调用。<br>如下：</p>
<p>*/</p>
<pre><code>public class ModFilter_Other
{
    private readonly int modules;


    //实例方法
    private bool WhereClause(int n)
    {
        return ((n%this.modules) ==0);
    }


    private static int SelectClause(int n)
    {
        return n * n;
    }

    private static Func&lt;int, int&gt; SelectDelegate;




    public ModFilter_Other(int mod)
    {
        modules = mod;
    }


    public IEnumerable&lt;int&gt; FindValues(IEnumerable&lt;int&gt; sequence)
    {
        if(SelectDelegate==null)
        {
            SelectDelegate = new Func&lt;int, int&gt;(SelectClause);
        }

        return sequence.Where&lt;int&gt;(
            new Func&lt;int, bool&gt;(this.WhereClause)).
            Select&lt;int, int&gt;(SelectClause);
    }
}
</code></pre><p>概括来说便是：lambda表达式中的代码访问了对象实例中的成员变量，那么编译器将生成实例方法来表示lambda表达式中的代码。其实这并没有什么奇特之处——编译器省去了我们的一些代码输入工作，代码也变得整洁很多，本质来说这还是普通的方法调用。</p>
<p>不过若是lambda表达式中访问到了外部方法中的局部变量或者方法参数，那么编译器将帮你完成很多工作。</p>
<p>这里会用到闭包。编译器将生成一个私有的嵌套类型，以便为局部变量实现闭包。</p>
<p>局部变量必须传入到实现了lambda表达式主体部分的委托里。</p>
<p>此外，所有由该lambda表达式执行的对这些局部变量所作的修改都必须能够在外部访问到。</p>
<p>当然，代码中内层和外层中共享的可能不止有一个变量，也可能不止一个的查询表达式。</p>
<p>我们来修改一下该实例方法，让其访问一个局部变量。</p>
<pre><code>public class ModFilter
{
      private readonly int modules;

      public ModFilter(int mod)
      {
          modules = mod;
      }


      public IEnumerable&lt;int&gt; FindValues(IEnumerable&lt;int&gt; sequence)
      {
          int numValues = 0;

          return from n in sequence
                 where n % modules == 0 //新添加的表达式
                 select n * n / ++ numValues; //访问局部变量
      }
}
</code></pre><p>注意，select字句需要访问numValues这个局部变量。编译器为了创建这个闭包，需要使用嵌套类型来实现你所需要的行为。下面展示的是编译器为你生成的代码。</p>
<pre><code>  public class ModFilter
 {
    private sealed class Closure
    {
        public ModFilter outer;

        public int numValues;

        public int SelectClause(int n)
        {
            return ((n * n) / ++this.numValues);
        }
    }



    private readonly int modules;


    //实例方法
    private bool WhereClause(int n)
    {
        return ((n % this.modules) == 0);
    }

    public ModFilter(int mod)
    {
        modules = mod;
    }


    public IEnumerable&lt;int&gt; FindValues(IEnumerable&lt;int&gt; sequence)
    {
        Closure c = new Closure();
        c.outer = this;
        c.numValues = 0;

        return sequence.Where&lt;int&gt;(
            new Func&lt;int, bool&gt;(this.WhereClause)).
            Select&lt;int, int&gt;(c.SelectClause);
    }
}
</code></pre><p>在上面这段代码中，编译器专门创建了一个嵌套类，用来容纳所有将在lambda表达式中访问或修改的变量。实际上，这些局部变量将完全被嵌套类的字段所代替。lambda表达式内部的代码以及表达式外部(但仍在当前方法内)的代码访问的均是同一个字段，lambda表达式中的逻辑也被编译成了内部类的一个方法。</p>
<p>对于lambda表达式中将要用到的外部方法的参数，编译器也会以对待局部变量的方式实现：编译器将这些参数复制到表示该闭包的嵌套类中。</p>
<p>回到最开始的那个示例，这是我们应该可以理解这种看似怪异的行为了。变量index在传入闭包后，但在查询开始执行前曾被外部代码修改。也就是说，你修改了闭包的内部状态，然后还期待其能够回到从前的状态开始执行，显然这是不可能实现的。</p>
<p>考虑到延迟执行中的交互以及编译器实现闭包的方式，修改查询与外部代码之间绑定的变量将可能会引发错误的行为。<br>因此，我们应该尽量避免在方法中修改哪些将要传入到闭包中，并将在闭包中使用的变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/03/01/技巧避免修改绑定变量/" data-id="cilgg02a50005s0un5hxyvhiv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-托管堆和垃圾回收" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/01/托管堆和垃圾回收/" class="article-date">
  <time datetime="2016-03-01T12:49:34.588Z" itemprop="datePublished">2016-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/GC/">GC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/托管堆和垃圾回收/">C#.NET托管堆和垃圾回收</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###托管堆基础<br> 简述：每个程序都要使用这样或那样的资源，包括文件、内存缓冲区、屏幕空间、网络连接…..事实上，在面向对象的环境中，每个类型都代表可供程序使用的一种资源。要使用这些资源，必须为代表资源的类型分配内存。</p>
<p> 以下是访问一个资源所需步骤：</p>
<ol>
<li>调用IL指令newobj，为代表资源的类型分配内存。(C# new操作符)</li>
<li>初始化内存，设置资源的初始状态。（一般指构造函数）</li>
<li>访问类型的成员来使用资源。（使用成员变量、方法、属性等）</li>
<li>摧毁资源的状态以进行清除。（Dispose？？？）</li>
<li>释放内存。（GC） </li>
</ol>
<p>###从托管堆分配资源</p>
<p>CLR要求所有的对象都从托管堆分配。<br>进程初始化，CLR划出一个地址空间区域作为托管堆。CLR还要维护一个指针，姑且叫NextObjPtr，该指针指向下一个对象在堆中的分配位置。刚开始的时候， NextObjPtr 设为地址空间区域的基地址。<br>一个区域被非垃圾对象填满后，CLR会分配更多的区域。</p>
<p>这一个过程一直重复，直至整个进程地址空间被填满。所以，应用程序内存收进程的虚拟地址空间的限制。</p>
<p>32位进程最多能分配1.5GB，64位进程最多能分配8T。<br>注：进程内存大小的相关资料</p>
<p><a href="https://msdn.microsoft.com/zh-cn/library/windows/hardware/Dn613959(v=vs.85" target="_blank" rel="external">Memory Support and Windows Operating Systems</a>.aspx)</p>
<p><a href="https://msdn.microsoft.com/zh-cn/library/ms189334.aspx" target="_blank" rel="external">进程地址空间</a></p>
<p><a href="http://blog.csdn.net/yusiguyuan/article/details/12405799" target="_blank" rel="external"> 32位模式下C/C++程序可用最大内存</a></p>
<p>###C# 的new操作符导致CLR执行以下操作：</p>
<p>1、计算类型的字段（以及从基类型继承的字段）所需要的字节数。</p>
<p>2、加上对象的开销所需的字节数。每个对象都有两个开销字段：类型对象指针和同步块索引。对于32位应用程序，这两个字段各需要32位，所以每个对象需要增加8字节。对于64位应用程序，这两个字段各需要64位，所以每个对象要增加16字节。</p>
<p>3、CLR检查区域中是否有分配对象所需的字节数。如果托管堆有足够的可用空间，就在NetxObjPtr指针指向的地址处放入对象，为对象分配的字节会被清零。接着调用类型的构造器（为this参数传递NextObjPtr），new操作符返回对象引用。就在返回这个对象引用之前，NextObjPtr指针的值会加上这个对象占用的字节数来得到一个新值，即下个对象放入托管堆时的地址。如下图：</p>
<p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/i3rlSCPAcnT9pL0El0BptPIBpuvnxHpBw9Nkp*UqIjw!/o/dJMAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=LwKNAC8CjQADACU!&amp;su=1199793361&amp;sce=0-12-12&amp;rf=2-9" alt=""></p>
<p>###垃圾回收算法</p>
<p>####CLR使用引用跟踪算法。<br>引用跟踪算法只关心引用类型的变量，因为只有这种变量才能引用堆上面的对象；<br>值类型变量直接包含值类型实例。引用类型变量可在许多场合使用，包括类的静态和实例字段，或者方法的参数和局部变量。这里我们将所有引用类型的变量都称为根。<br>CLR开始GC时，首先暂停所有的线程。(这样可以防止线程在CLR检查期间访问对象并更改其状态。) 然后CLR进入GC标记阶段。在这个阶段，CLR遍历堆中的所有对象，将同步块索引字段中的一位设为0。这表明所有的对象都应删除。然后，CLR检查所有的活动根，查看他们引用了哪些对象。这正是CLR的GC被称作引用跟踪GC的原因。如果一个根包含null，CLR忽略这个根并继续检查下一个根。<br>下图展示一个堆，其中包含几个对象。<br><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/eVBVeXGrNAfoWfyRgl4aC2RRSGgiDpmbrocv4lTSJMA!/o/dJIAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=gAIFAYACBQEDACU!&amp;su=1176931729&amp;sce=0-12-12&amp;rf=2-9" alt="图片1"></p>
<p>应用程序的根直接引用对象A 、C、D 、F。所有的对象都已经被标记。标记对象D时，GC发现这个对象含有一个引用对象H的字段，造成对象H也被标记。标记过程会持续，直至应用程序的所有根所有检查完毕。<br>检查完毕后，堆中的对象要么已标记，要么未标记。已标记的对象不能被垃圾回收，因为至少有一个根在引用它。我们说这种对象是可达的，因为应用程序可以通过引用它的变量抵达它。 未标记的对象是不可达的，因为应用程序中不存在使对象能被再次访问的根。</p>
<p>CLR知道哪些对象可以幸存，哪些可以被删除后，进入GC的压缩（类似于碎片整理）阶段。在压缩阶段，CLR对堆中已标记的对象进行“乾坤大挪移”，整理所有幸存下来的对象，使他们占用连续的内存。</p>
<p>这样做的好处在于：</p>
<p>1、所有幸存对象在内存中紧挨在一起，恢复了引用的“局部性”，减少了应用程序的工作集，从而提升了将来访问这些对象时的性能；</p>
<p>2、经过整理后，可用空间也是连续的，整个地址空间区段得到了解放，允许其他东西进驻。</p>
<p>在内存中移动了对象之后有一个问题亟待解决。引用幸存对象的根现在引用的还是对象最初在内存中的位置，而非移动后的位置。被暂停的线程恢复执行时，将访问旧的内存位置，会造成内存损坏。 这显然是不能容忍的，所以作为压缩阶段的一部分，CLR还要从每个根减去所引用对象在内存中偏移的字节数。这样就能保证每个根还是引用和之前一样的对象，只是对象在内存中变换了位置。<br>如图：<br><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/FyP2yk1O6kMsq3.u4e4x3qrAxpwbajgSHOd4QHTJOhE!/o/dJIAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=TQI*AU0CPwEDACU!&amp;su=1202148209&amp;sce=0-12-12&amp;rf=2-9" alt=""></p>
<p>##代：提升性能 (待续)<br>CLR的GC是基于代的垃圾回收器，它对你的代码做出了以下几点假设：</p>
<p>1、对象越新，生存周期越短。</p>
<p>2、对象越老，生存周期越长。</p>
<p>3、回收堆的一部分 ，速度快于回收整个堆。</p>
<p>大量研究表明，这些假设对于现今大多数的应用程序都是成立的，它们影响了垃圾回收器的实现方式。这里将解释代的工作原理。</p>
<p>托管堆在初始化时不包括对象。添加到堆的对象成为第0代对象。简单来说，第0代对象就是那些新构造的对象，垃圾回收器从未检查过它们。如下图，新启动的应用程序，分配了5个对象（从A到E）。过了一会，C和E变得不可达了。</p>
<p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/77WJus7lssJpEJ2RZREQoNx.5CL31HLdboJbAgCqS0E!/o/dJMAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=tQIVAbUCFQEDACU!&amp;su=172682065&amp;sce=0-12-12&amp;rf=2-9" alt=""></p>
<p>CLR初始化第0代对象选择一个预算容量。如果分配一个新对象造成第0代超预算，就必须启动一次GC。假设对象A到E刚好用完了第0代的空间，那么分配对象F就必须启动GC。GC之后存活的对象现场成为第1代对象。如下图：</p>
<p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/GEDzaV4pNFNQUuDwl2EQrv*eD9Sk9OJCzx5SpRRI2fk!/o/dGUBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=OAL5ADgC.QADACU!&amp;su=1155276897&amp;sce=0-12-12&amp;rf=2-9" alt=""><br>一次GC之后，第0代就不包含任何对象。和前面一样，新对象会分配到第0代。新分配对象F到对象K都到了第0代。<br><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/Op0QokzBTNYCFR6zzm2tpc2V7U70IsIJTeWrd0UAUb0!/o/dGUBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=yAJeAcgCXgEDACU!&amp;su=1124261217&amp;sce=0-12-12&amp;rf=2-9" alt=""></p>
<p>之后，程序继续运行，B、H、J变得不可达，它们的内存将在某一个时刻回收。</p>
<p>假设现在新分配对象L会造成第0代超出预算,造成必须启动垃圾回收。</p>
<p>开始垃圾回收时,垃圾回收器必须决定检查哪些代。前面说过,CLR初始化时会为第0代对象选择预算.事实上,它还必须为第1代选择预算.</p>
<p>开始一次垃圾回收时,垃圾回收器还会检查第一代占用了多少内存。在本例中,由于第1代占用内存远少于预算,所以垃圾回收器只检查第0代对象。回顾之前基于代的垃圾回收器做出的第一个假设：对象越新，生存期越短。 因此，第0代包含更多的垃圾的可能性更大，能回收更多的内存。由于忽略第1代中的对象，所以加快了垃圾回收速度。</p>
<p>显然，忽略第1代中的对象能提升垃圾回收器的性能。但对性能有更大提振作用的是现在不必遍历托管堆中的每个对象。如果根或对象引用了老一代的某个对象，垃圾回收器就可以忽略老对象内部的所有引用，能在更短的时间内构造好可达对象图。当然，如果老对象的字段也可能引用新对象。为了确保对老对象的已更新字段进行检查，垃圾回收器利用了JIT编译器内部的一个机制。这个机制在对象的引用字段发生变化时，会设置一个对应的标志位。这样，垃圾回收器就知道自上一次垃圾回收以来，哪些老对象（如果有的话）已被写入。只有字段发生变化的老对象才需要检查是否引用了第0代中的任何新对象。</p>
<p>基于代的垃圾回收器还假设越老的对象活得越长。也就是说，第1代对象在应用程序中有可能是继续可达的。如果垃圾回收器检查第1代的对象，很有可能找不到多少垃圾，结果是也回收不了多少内存。因此，对第1代进行垃圾回收很可能是浪费时间的。如果第一代真有垃圾，垃圾将留在那里。如下图：<br><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/Do.yRCBJEnaOfZaUOdxj4II9*pX2BEcX2QmIG6NQPBE!/o/dGUBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=qAI5AagCOQEDACU!&amp;su=187009937&amp;sce=0-12-12&amp;rf=2-9" alt=""></p>
<p>程序继续运行，继续往第0代分配对象，同时程序停止对第1代某对象的使用。</p>
<p>如下图：<br><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/YEqIM16xFsSgXdvEzgrerLnKw7fEItnrSqEzlaYnUfE!/o/dGUBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=egJPAXoCTwEDACU!&amp;su=1118118497&amp;sce=0-12-12&amp;rf=2-9" alt=""><br>分配对象P导致第0代超预算，开始GC。第1代的所有对象占据内存仍小于预算，垃圾回收器再次决定只回收第0代。忽略第1代中的垃圾对象。如下图：<br><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/EcdSNU5AatqRERWtVdlJ7LiIPHHXe8.mklN.0hHDK9U!/o/dJQAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=aAIxAWgCMQEDACU!&amp;su=1214124305&amp;sce=0-12-12&amp;rf=2-9" alt=""></p>
<p>程序继续运行，假设第一代的增长导致它的全部对象占用了全部预算。这时候应用程序分配对象P到对象S，使第0代对象达到它的预算总和。如下图：<br><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/6dB68RIUYrqMZ4p0VIY3REJZPg.g3ybkZFIazJ3h.CQ!/o/dJIAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=jwIiAY8CIgEDACU!&amp;su=177976657&amp;sce=0-12-12&amp;rf=2-9" alt=""></p>
<p>这时候，应用程序准备分配对象T，由于第一代已满，所以必须开始GC。但这一次垃圾回收器发现第一代占用了太多内存，以至于用完了预算。由于前几次对第0代进行GC时，第1代中可能已经有很多对象变得不可达。所以这次垃圾回收器决定检查第1代和第0代中的所有对象。两代都被垃圾回收后，堆的情况如下图：<br><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/bxdZDsZi2Y6FSDWs7RXNPkkJK8dCzMD.cfnjwNY2Mjs!/o/dJIAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=tgI2AbYCNgEDACU!&amp;su=197762641&amp;sce=0-12-12&amp;rf=2-9" alt=""></p>
<p>托管堆只支持三代：第0代、第1代和第2代。</p>
<p>CLR初始化时，会为每一代选择预算。</p>
<p>然而，CLR的垃圾回收是自调节的。</p>
<p>这意味着垃圾回收器会在执行垃圾回收的过程了解程序的行为。</p>
<p>例如：假设应用程序构造了许多对象，但每个对象的时间都很短。<br>在这种情况下，对第0代的垃圾回收会回收到大量的内存。事实上，第0代的所有对象都可能被回收。</p>
<p>如果垃圾回收器发现在回收第0代后存活下来的对象很少，就可能减少第0代的预算。已分配空间的减少意味着垃圾回收将更频繁地发生，但垃圾回收器每次做的事情也减少，这减少了进程的工作集。</p>
<p>另一方面，如果垃圾回收器回收了第0代，发现还有很多对象存活，没多少内存可以被回收，就会增大第0代的预算。</p>
<p>同样的启发性算法调整预算适用于了第1代和第2代的预算。</p>
<p>引自：《CLR VIA C# -21章》</p>
<p><a href="https://msdn.microsoft.com/zh-cn/library/vstudio/f144e03t(v=vs.100" target="_blank" rel="external">自动内存管理</a>.aspx)</p>
<p><a href="https://msdn.microsoft.com/zh-cn/library/vstudio/ee787088(v=vs.100" target="_blank" rel="external">垃圾回收的基础</a>.aspx)</p>
<p><a href="https://msdn.microsoft.com/zh-cn/library/vstudio/ee787088(v=vs.100" target="_blank" rel="external">代数</a>.aspx#generations )</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/03/01/托管堆和垃圾回收/" data-id="cilgg02ae0007s0unlh2p02jv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-托管堆和垃圾回收(续)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/01/托管堆和垃圾回收(续)/" class="article-date">
  <time datetime="2016-03-01T12:49:34.588Z" itemprop="datePublished">2016-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/GC/">GC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/托管堆和垃圾回收(续)/">C#.NET托管堆和垃圾回收(续)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##大对象<br> CLR将对象分成大对象和小对象。目前认为85000字节或者更大的对象是大对象。CLR以不同方式对待大小对象。</p>
<ol>
<li><p>大对象不是在小对象的地址空间分配的，而是在进程地址空间的其他地方分配。</p>
</li>
<li><p>目前版本的GC不“压缩”大对象，因为在内存中移动它们代价过高。但这可能在进程中的大对象之间造成地址空间碎片化，以至于抛出OutMemoryException。CLR将来的版本可能会压缩大对象。</p>
</li>
<li>大对象总是第2代，绝不可能是第0代或者第1代。所以只能为需要长时间存活的资源创建大对象。分配短时间存活的大对象会导致第2代被更频繁地回收，损失性能。大对象一般是大字符串（XML/JSON）或者用于I/O操作的字节数组（从文件/网络将字节读入缓冲区以便处理）。</li>
</ol>
<p>##垃圾回收模式<br> CLR启动时会选择一个GC模式，进程中之前该模式都不会改变。</p>
<p> 有两个基本GC模式。</p>
<p>###工作站<br>该模式针对客户端应用程序优化GC。GC造成的延时很低，应用程序线程挂起时间很短，避免用户感到焦虑。在该模式中,GC假定机器上运行的其他应用程序都不会消耗太多的CPU资源。</p>
<p>###服务器<br> 该模式针对服务器端应用程序优化GC。被优化的主要是吞吐量和资源利用。GC假定机器上没有运行其他应用程序（无论客户端还是服务器应用程序），并假定机器的所有CPU都可以用来辅助完成GC。该模式造成托管堆被拆分成几个区域，每个CPU一个。开始垃圾回收时，垃圾回收器在每个CPU上运行一个特殊线程；每个线程都和其他线程并发回收它自己的区域。对于工作者线程行为一致的服务器应用程序，并发回收能很好进行。这个功能要求应用程序在多CPU计算机上运行，是线程能真正同时工作，从而得到性能上的提升。</p>
<p>应用程序默认以“工作站”GC模式运行。寄宿了CLR的服务器应用程序（如ASP.NET ）可请求CLR加载服务器 GC.但如果应用程序在单处理器计算机上运行，CLR总是使用“工作站”GC模式。</p>
<p>独立应用程序可以创建一个配置文件告诉CLR 使用CLR使用服务器回收器。配置文件要为应用程序添加gcServer元素。下面是一个示例配置文件：</p>
<p><configuration><br>       <runtime><br>             <gcserver enabled="true"><br>      </gcserver></runtime><br></configuration><br>可以使用GCSettings类的只读Boolean属性IsServerGC得到CLR是否处于“服务器”GC模式。</p>
<p>除了这两种模式，GC还支持两种子模式：并发(默认)或者非并发。<br>在并发方式中，垃圾回收器有一个额外的后台线程，它能在应用程序运行时并发标记对象。 程序运行时，垃圾回收器运行一个普通优先级的后台线程来查找不可达对象。找到之后，垃圾回收器再次挂起所以线程，判断是否要“压缩”内存。如决定压缩，内存会被压缩，根引用会被修正，应用程序线程恢复运行。这一次垃圾回收花费的时间比平常少，因为不可达对象集合已构造好了。但垃圾回收器也可能决定不压缩内存；事实上，垃圾回收器更倾向不压缩。可用内存多，垃圾回收器便不会压缩堆；这有利于增强性能，但会增大程序的工作集。使用并发垃圾回收器，应用程序消耗的内存通常比使用非并发垃圾回收器多。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/03/01/托管堆和垃圾回收(续)/" data-id="cilgg02aj000as0unpksbzafw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-类字段与类属性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/01/类字段与类属性/" class="article-date">
  <time datetime="2016-03-01T12:49:34.588Z" itemprop="datePublished">2016-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/net/">.net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/类字段与类属性/">.NET 类字段与类属性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#.NET 类字段与类属性<br>@(.NET)[基础|字段|属性]</p>
<p>##字段<br>字段表示只读或可读/可写的数据值。<br>字段可以是静态的，这种字段被认为是类型状态的一部分。<br>字段也可以是实例（非静态），这种字段被认为是对象状态的一部分。<br>强烈建议把字段声明为私有，防止类型或对象的状态被类型外部代码破坏。</p>
<p>##属性<br>属性允许用简单的、字段风格的语法设置或查询类型或对象的逻辑状态，同时保证状态不被破坏。<br>作用于类型称为静态属性，作用于对象称为实例属性。<br>属性可以无参，也可以有多个参数（相当少见，但集合类用的多）。 </p>
<pre><code>using System;

public sealed class SomeType
{                            //  1  
// Nested class  
   private class SomeNestedType { }                //  2  

   // Constant, read­only, and static read/write field   
   private const Int32 c_SomeConstant = 1;            //  3     

   private readonly String m_SomeReadOnlyField = &quot;2&quot;;     //  4    

   private static Int32 s_SomeReadWriteField = 3;      //  5  

   // Type constructor  
   static SomeType() { }                                  //  6  

   // Instance constructors  
   public SomeType(Int32 x) { }                           //  7  

   public SomeType() { }                                  //  8 

   // Instance and static methods  
   private String InstanceMethod() { return null; }       // 9   

   public static void Main() { }                        // 10 

   // Instance property  
   public Int32 SomeProp
   {                                // 11      
       get { return 0; }                                // 12      
       set { }                                          // 13  
   }

   // Instance parameterful property (indexer) 
   public Int32 this[String s]
   {                          // 14       
       get { return 0; }                                // 15        
       set { }                                          // 16  
   }

   // Instance event  
   public event EventHandler SomeEvent;                  // 17  
}
</code></pre><p><img src="https://kekaeq-ch3301.files.1drv.com/y3meEWWaK-o9SNfr_fT71Xr3YrPqO1LIswWqMvlHyUxWeH8P0PtXsQlfRkDnGshlMJIy2gPsxNet14efOPOuX-dHmZhCTg8PXyELJR9tnayye4LeEQ6F997b8pSI84wBR6nmmOF8IAr92oKWk36-f8alkEj9TrDQbiMoKGQwO5MTFY/20150105.jpg?psid=1" alt="enter image description here"></p>
<p><img src="https://kekaeq-ch3301.files.1drv.com/y3mN8FseIEbAaQfT8ynEIc4nYsOUK0p0IN7Hp39imVSZXNQXlSfAYmvaC-9bDM3Hq6rPCV1XgrgvoST8wXejwARXaDmXptZpb_nyWwUzWK1rzaJ6fSsYfnP0icRKUclaVxnlltOJSQiuTFO7_fCfabmv0AsrgL5sLo6GdVJmpd-L10/QQ%E5%9B%BE%E7%89%8720151003165909.jpg?psid=1" alt="enter image description here"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/03/01/类字段与类属性/" data-id="cilgg02a00003s0unhqc6j549" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-一些有用的网站" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/01/一些有用的网站/" class="article-date">
  <time datetime="2016-03-01T12:49:34.588Z" itemprop="datePublished">2016-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nothing/">nothing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/一些有用的网站/">一些有用的网站</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown 语法说明 (简体中文版)</a></p>
<p><a href="http://wowubuntu.com/markdown/basic.html" target="_blank" rel="external">Markdown: Basics （快速入门）</a></p>
<p><a href="http://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="external">使用GitHub和Hexo搭建免费静态Blog(本博客案例)</a></p>
<p><a href="https://www.mxgw.info/t/filename-too-long-in-git.html" target="_blank" rel="external">win下面的git客户端提示FIlename too long解决方法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/03/01/一些有用的网站/" data-id="cilgg02an000cs0unlsl9csmu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LINQ优点总结(转载)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/01/LINQ优点总结(转载)/" class="article-date">
  <time datetime="2016-03-01T12:49:34.572Z" itemprop="datePublished">2016-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/net/">.net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/LINQ优点总结(转载)/">C#LINQ 优点 总结(转载)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文链接：<a href="http://www.cnblogs.com/c-jquery-linq-sql-net-problem/archive/2011/01/15/LINQ_Merit.html" target="_blank" rel="external">http://www.cnblogs.com/c-jquery-linq-sql-net-problem/archive/2011/01/15/LINQ_Merit.html</a></p>
<p>这几天在读一本LINQ方面的书《Essential LINQ》,在这里和大家分享下。</p>
<p>由于对LINQ的深入总结需要大量的篇幅，因此在这里分成几个部分来讲。</p>
<p>（*我看《Essential LINQ》是英文版的，有些名词不能翻译成正统的中文解释请给予谅解）</p>
<p>LINQ的优点：</p>
<p>LINQ基本有以下七个优点，让我来一一举例说明：</p>
<p>#####1.Integrated：所谓的Integrated（集成化），LINQ是从以下方面体现集成的：</p>
<p>(1):把查询语法融入了C#(VB)这些语言中，让他变成了一种语法。这样就能和C#中的其他语法一样支持：</p>
<p>语句高亮显示，类型检查，允许使用debugger调试</p>
<p>(2):把以前复杂的查询前的工作都集成封装起来，让开发人员侧重于查询。</p>
<p>(3):集成后的语法更加的清晰易懂，可读性较高。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">比较： </span><br><span class="line"><span class="comment">//原来的格式</span></span><br><span class="line">SqlConnection sqlConn = <span class="keyword">new</span> SqlConnection(connectionString);&gt;</span><br><span class="line">sqlConn.Open();</span><br><span class="line">SqlCommand command = <span class="keyword">new</span> SqlCommand();</span><br><span class="line">command.Connection = sqlConn;</span><br><span class="line">command.CommandText = <span class="string">"Select * From Customer"</span>;</span><br><span class="line">SqlDataReader dataReader = command.ExecuteReader(CommandBehavior.CloseConnection);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//LINQ的格式</span></span><br><span class="line">NORTHWNDDataContext dc = <span class="keyword">new</span> NORTHWNDDataContext();</span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> c <span class="keyword">in</span> dc.Customers</span><br><span class="line">            <span class="keyword">select</span> c;</span><br></pre></td></tr></table></figure>
<p>#####2.Unitive：所谓Unitive(统一化)就指不管对任何类型外部和内部数据源(对象集合,xlm,数据库数据)都使用统一的查询语法。</p>
<p>使用统一化查询语言的好处在于以下几点：</p>
<p>你不用因为要使用不太熟悉的数据源而花很多精力去了解它，你可以快速简单的使用LINQ语法对起查询。<br>由于使用了统一的语法，可以使代码维护变的更加简单。<br>以下代码体现了LINQ的统一化：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据源:对象集合</span></span><br><span class="line"><span class="keyword">var</span> query = <span class="function"><span class="keyword">from</span> c <span class="keyword">in</span> <span class="title">GetCustomers</span>(<span class="params"></span>)</span><br><span class="line">            <span class="keyword">select</span> c</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//数据源:SQL</span></span><br><span class="line"><span class="keyword">var</span> query1 = <span class="keyword">from</span> c <span class="keyword">in</span> dc.Customers</span><br><span class="line">             <span class="keyword">select</span> c;</span><br><span class="line"><span class="comment">//数据源:XML</span></span><br><span class="line"><span class="keyword">var</span> query2 = <span class="keyword">from</span> c <span class="keyword">in</span> customers.Descendants(<span class="string">"Customer"</span>)</span><br><span class="line">             <span class="keyword">select</span> c;</span><br></pre></td></tr></table></figure></p>
<p>#####3.Extensible：所谓Extensible(可扩展)指以下2个方面:</p>
<p>(1).可查询数据源的扩展。 LINQ提供了个LINQ provider model，你可以为LINQ创建或提供provider让LINQ支持更多的数据源。</p>
<p>(2).可扩展查询方法。开发者可以根据自己的需求为LINQ重写和扩展查询方法。</p>
<p>以下是些第三方的LINQ provider：</p>
<p>LINQ Extender, LINQ to JavaScript, LINQ to JSON, LINQ to MySQL, LINQ to Flickr, LINQ to Google</p>
<p>#####4.Declarative：所谓Declarative(声明式)，简单的来说指的是开发人员只要告诉程序做什么，程序自己判断怎么做。</p>
<p>Declarative programming(声明式编程)的优点体现在以下2点：</p>
<p>(1).提高了开发速度。因为开发者不用书写大量的代码来具体化执行步骤，只许告诉程序做什么。</p>
<p>(2).提高代码优化空间。因为开发者不用参与干涉对程序执行的具体步骤，这样就提供给编译器更多的空间去优化代码。</p>
<p>举例SQL来说，LINQ生成的SQL语句往往比一对SQL水平一般的开发者能写出更好的SQL语句。</p>
<p>比较Declarative programming 与 Imperative programming：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明式编程</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; lists = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; &#123; <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">4</span>, <span class="number">5</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> query = from list <span class="keyword">in</span> lists</span><br><span class="line">            from <span class="built_in">num</span> <span class="keyword">in</span> list</span><br><span class="line">            where <span class="built_in">num</span> % <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">            orderby <span class="built_in">num</span> descending</span><br><span class="line">            select <span class="built_in">num</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//命令式编程</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list1 = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">list1.Add(<span class="number">1</span>);</span><br><span class="line">list1.Add(<span class="number">2</span>);</span><br><span class="line">list1.Add(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list2 = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">list2.Add(<span class="number">4</span>);</span><br><span class="line">list2.Add(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; lists1 = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">lists1.Add(list1);</span><br><span class="line">lists1.Add(list2);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; newList = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">foreach (<span class="keyword">var</span> item <span class="keyword">in</span> lists1)</span><br><span class="line">      foreach (<span class="keyword">var</span> <span class="built_in">num</span> <span class="keyword">in</span> item)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">num</span> % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            newList.Add(<span class="built_in">num</span>);</span><br><span class="line">newList.Reverse();</span><br></pre></td></tr></table></figure></p>
<p>#####5.Hierarchical：所谓Hierarchical(层次化)指使用面向对象的方式抽象数据。</p>
<p>SQL是关系型数据库，它以关系的方式描述数据以数据的联系，但我们的程序设计成面向对象的因此我们在程序里得到的数据库数据往往都是</p>
<p>rectangular grid（平面的显示数据）。但是LINQ通过所谓的O-R Mapping方式，把关系型转换成对象与对象方式描述数据。</p>
<p>这样带来的好处是：开发者能直接以对象的方式去操作数据，对习惯面向对象的开发者来说面向对象模型更易理解。</p>
<p>#####6.Composable：所谓Composable(可组成)指LINQ可以把一个复杂的查询拆分成多个简单查询。</p>
<p>LINQ返回的结果都是基于接口：IEnumerable<t>，因此能对查询结果继续查询，而且LINQ具有延迟执行的特性因此拆分执行不会影响效率。</t></p>
<p>优点在于：</p>
<p>(1).方便调试。把复杂的查询拆分成简单的查询，然后逐个调试。</p>
<p>(2).便于代码维护。把代码拆分后能使代码变的更易理解。</p>
<p>以下代码体现了可组成性：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码体现了Composable</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; lists = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; &#123; <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;</span><br><span class="line"> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">4</span>, <span class="number">5</span> &#125; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> query1 = from list <span class="keyword">in</span> lists</span><br><span class="line">             from <span class="built_in">num</span> <span class="keyword">in</span> list</span><br><span class="line">             select <span class="built_in">num</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> query2 = from <span class="built_in">num</span> <span class="keyword">in</span> query1</span><br><span class="line">             where <span class="built_in">num</span> % <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">             select <span class="built_in">num</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> query3 = from <span class="built_in">num</span> <span class="keyword">in</span> query2</span><br><span class="line">             orderby <span class="built_in">num</span> descending</span><br><span class="line">             select <span class="built_in">num</span>;</span><br></pre></td></tr></table></figure></p>
<p>######7.Transformative：所谓Transformative(可转换)指的是LINQ能把一种数据源的内容转换到其他数据源。</p>
<p>方便用户做数据移植。</p>
<p>以下代码体现了转换的特性：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把关系型数据转换成XML型</span></span><br><span class="line">	<span class="keyword">var</span> query = <span class="keyword">new</span> XElement(<span class="string">"Orders"</span>,</span><br><span class="line">            <span class="keyword">from</span> c <span class="keyword">in</span> dc.Customers</span><br><span class="line">            <span class="keyword">where</span> c.City == <span class="string">"Paris"</span></span><br><span class="line">            <span class="function"><span class="keyword">select</span> new <span class="title">XElement</span>(<span class="params"><span class="string">"Order"</span>,</span><br><span class="line">                new XAttribute(<span class="string">"Address"</span>, c.Address</span>)))</span>;</span><br></pre></td></tr></table></figure></p>
<p>以上就是LINQ的几大优点，很高兴能在这里和大家分享。有任何不足之处请给予补充和纠正，谢谢光临小舍。</p>
<p>//2011/1/28 补充(LINQ TO SQL)</p>
<p>在LINQ TO SQL 方面，如果使用LINQ TO SQL可以有效的防止SQL注入，LINQ TO SQL 会把注入的代码当做无用的参数处理。</p>
<p><a href="http://www.cnblogs.com/c-jquery-linq-sql-net-problem/archive/2011/01/15/LINQ_Merit.html" target="_blank" rel="external">http://www.cnblogs.com/c-jquery-linq-sql-net-problem/archive/2011/01/15/LINQ_Merit.html</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/03/01/LINQ优点总结(转载)/" data-id="cilgg02az000is0unnor0dd3v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Join" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/01/Join/" class="article-date">
  <time datetime="2016-03-01T12:49:34.572Z" itemprop="datePublished">2016-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/net/">.net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/Join/">.NET-join用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#.NET   Join<br> 连接：内连接、外连接、左连接、右连接。<br>SQL的Join这里就不多说了，<br>今天主要是看一下LINQ的Join用法，以及Enumerable.Join()的用法。</p>
<p>Join用于连接数据，首先就是数据之间有联系咯。</p>
<p>先说Enumerable.Join()。<br>参数类型如下：<br>            public static IEnumerable<tresult> Join<touter, tinner,="" tkey,="" tresult=""><br>            (<br>                     this IEnumerable<touter> outer,<br>                    IEnumerable<tinner> inner,<br>                    Func<touter, tkey=""> outerKeySelector,<br>                    Func<tinner, tkey=""> innerKeySelector,<br>                    Func<touter, tinner,="" tresult=""> resultSelector<br>            )<br>类型参数<br>TOuter<br>第一个序列中的元素的类型。<br>TInner<br>第二个序列中的元素的类型。<br>TKey<br>键选择器函数返回的键的类型。<br>TResult<br>结果元素的类型。<br>参数<br>outer<br>类型：System.Collections.Generic.IEnumerable<touter><br>要联接的第一个序列。<br>inner<br>类型：System.Collections.Generic.IEnumerable<tinner><br>要与第一个序列联接的序列。<br>outerKeySelector<br>类型：System.Func<touter, tkey=""><br>用于从第一个序列的每个元素提取联接键的函数。<br>innerKeySelector<br>类型：System.Func<tinner, tkey=""><br>用于从第二个序列的每个元素提取联接键的函数。<br>resultSelector<br>类型：System.Func<touter, tinner,="" tresult=""><br>用于从两个匹配元素创建结果元素的函数。<br>返回值<br>类型：System.Collections.Generic.IEnumerable<tresult><br>IEnumerable&lt;T&gt; that has elements of type TResult that are obtained by performing an inner join on two sequences.” xml:space=”preserve”&gt;一个具有 TResult 类型元素的 IEnumerable<t>，这些元素是通过对两个序列执行内部联接得来的。<br>使用说明<br>在 Visual Basic 和 C# 中，可以在 IEnumerable<touter> 类型的任何对象上将此方法作为实例方法来调用。当使用实例方法语法调用此方法时，请省略第一个参数。有关详细信息，请参阅 扩展方法 (Visual Basic) 或 扩展方法（C# 编程指南）。</touter></t></tresult></touter,></tinner,></touter,></tinner></touter></touter,></tinner,></touter,></tinner></touter></touter,></tresult></p>
<p>先上一个MSDN的例子。</p>
<pre><code>     public static void JoinEx1()         
     {
       Person magnus = new Person { Name = &quot;Hedlund, Magnus&quot; };
       Pet barley = new Pet { Name = &quot;Barley&quot;, Owner = terry };
       Person terry = new Person { Name = &quot;Adams, Terry&quot; };
       Person charlotte = new Person { Name = &quot;Weiss, 
       Charlotte&quot; };
       Pet boots = new Pet { Name = &quot;Boots&quot;, Owner = terry };
       Pet whiskers = new Pet { Name = &quot;Whiskers&quot;, 
       Owner = charlotte};
       Pet daisy = new Pet { Name = &quot;Daisy&quot;, Owner = magnus };

    List&lt;Person&gt; people = new List&lt;Person&gt; 
    { magnus, terry, charlotte };
    List&lt;Pet&gt; pets = new List&lt;Pet&gt; 
    { barley, boots, whiskers, daisy };

    // Create a list of Person-Pet pairs where 
    // each element is an anonymous type that contains a
    // Pet&apos;s name and the name of the Person that owns the Pet.
    var query =
        people.Join(
                    pets,//需要Join的另一个数据源
          person =&gt; person,//自己用来比较的key， lambda 表达式
     pet =&gt; pet.Owner,//另一个数据源用来比较的key， lambda 表达式
(person, pet) =&gt;new { OwnerName = person.Name, Pet = pet.Name } 
               //想要取出来的数据，支持匿名对象， lambda 表达式);
    foreach (var obj in query)
    {
      Console.WriteLine( &quot;{0} - {1}&quot;,obj.OwnerName,obj.Pet);
    }
}
</code></pre><p> LINQ的Join<br>同样是上面的数据，如果换成LINQ的Join，写法如下：<br>            var query = from person in people // 第一个数据源<br>                      join pet in pets            //第二个数据源<br>                      on person equals pet.Owner  //Join条件<br>                      select  new { OwnerName = person.Name, Pet = pet.Name };<br>                      //要到得到的数据。</p>
<p>上面两种写法得到的结果都是内链接结果，至于左连接、右连接、外连接….<br>等我下次有心情再更新吧，再不走家里的键盘又要坏了。 </p>
<p>一些资料链接：<br><a href="https://msdn.microsoft.com/zh-cn/library/bb311040.aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/bb311040.aspx</a><br><a href="https://msdn.microsoft.com/zh-cn/library/bb534675%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/bb534675%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396</a><br><a href="http://www.cnblogs.com/Ivony/archive/2008/08/18/1270555.html" target="_blank" rel="external">http://www.cnblogs.com/Ivony/archive/2008/08/18/1270555.html</a><br><a href="http://www.cnblogs.com/Ivony/archive/2008/08/28/1278643.html" target="_blank" rel="external">http://www.cnblogs.com/Ivony/archive/2008/08/28/1278643.html</a><br><a href="http://www.cnblogs.com/Ivony/archive/2008/10/14/1309807.html" target="_blank" rel="external">http://www.cnblogs.com/Ivony/archive/2008/10/14/1309807.html</a> ; </p>
<p>LINQ GroupJoin 实现左连接<br>var queryGroup = from person in people // 第一个数据源<br>                                join pet in pets //第二个数据源<br>                                on person equals pet.Owner into ps //加了into,华丽变身GroupJoin<br>                                select new { OwnerName = person.Name, Pet = ps }; //要到得到的数据。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/03/01/Join/" data-id="cilgg02b6000ks0unsen30995" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CodeSmith连接MySQL报错“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/01/CodeSmith连接MySQL报错“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法/" class="article-date">
  <time datetime="2016-03-01T12:49:34.572Z" itemprop="datePublished">2016-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CodeSmith/">CodeSmith</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/CodeSmith连接MySQL报错“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法/">CodeSmith 连接MySQL数据库报“can&#39;t find .net framework data provider”</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、下载 mysql-connector-net 安装</p>
<p><a href="https://dev.mysql.com/downloads/connector/net/6.9.html" target="_blank" rel="external">mysql-connector-net</a></p>
<p>2、mysql-connector-net 安装完毕之后，到对应的安装目录下，把对应的MySQL .NET dll拷贝到 CodeSmith的bin目录和SchemaProviders目录。</p>
<p>一般DLL所在目录是：</p>
<p>C:\Program Files (x86)\MySQL\MySQL Connector Net 6.9.8\Assemblies\v4.0</p>
<p>3、重启CodeSmith生效</p>
<p><br><br><br></p>
<p>其余解决方案：<br><br><br><a href="http://blog.csdn.net/joke01/article/details/9469515" target="_blank" rel="external">codesmith无法连接Mysql的解决方法</a></p>
<p><a href="http://www.cnblogs.com/tim190/archive/2013/01/18/2866161.html" target="_blank" rel="external">codesmith6.5连接Mysql提示“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/03/01/CodeSmith连接MySQL报错“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法/" data-id="cilgg02bd000ms0unhbwhpgw2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/net/">.net</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CodeSmith/">CodeSmith</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GC/">GC</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nothing/">nothing</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ubuntu/">ubuntu</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/03/06/ubuntu使用jexus搭建mywebsql/">ubuntu使用Jexus搭建MyWebSQL</a>
          </li>
        
          <li>
            <a href="/2016/03/03/Bytes -To-String/">bytes to string</a>
          </li>
        
          <li>
            <a href="/2016/03/01/技巧避免修改绑定变量/">.NET-lmabda避免修改绑定变量</a>
          </li>
        
          <li>
            <a href="/2016/03/01/托管堆和垃圾回收/">C#.NET托管堆和垃圾回收</a>
          </li>
        
          <li>
            <a href="/2016/03/01/托管堆和垃圾回收(续)/">C#.NET托管堆和垃圾回收(续)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 李国宝<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>