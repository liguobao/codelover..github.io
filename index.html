<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>codelover&#39;t blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一直走在吃软饭路上的软狗">
<meta property="og:type" content="website">
<meta property="og:title" content="codelover't blog">
<meta property="og:url" content="http://codelover.link/index.html">
<meta property="og:site_name" content="codelover't blog">
<meta property="og:description" content="一直走在吃软饭路上的软狗">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="codelover't blog">
<meta name="twitter:description" content="一直走在吃软饭路上的软狗">
  
    <link rel="alternative" href="/atom.xml" title="codelover&#39;t blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">codelover&#39;t blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://codelover.link"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CodeSmith to MySQL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/28/CodeSmith to MySQL/" class="article-date">
  <time datetime="2016-02-27T16:32:58.683Z" itemprop="datePublished">2016-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CodeSmith/">CodeSmith</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/28/CodeSmith to MySQL/">CodeSmith for MySQL template</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于.NET平台上的代码生成器来说，codesmith是一个非常好的选择。</p>
<p><br><br>以前在学院实验室用的都是SQL server数据库，老师给的一套codesmith模板用来生成model/DAL/BLL很是方便。<br><br><br>不过后来放弃SQL server 投入MySQL之后，刚开始都是手写SQL，还是很痛苦的。<br><br><br>再后来又去找MySQL codesmith模板,这个对应的资料就不多了。不过最后还是找到了一套不错的，凑合能用。起初也懒，codesmith语法不熟，就没想过去修改一下了。<br><br> 最近又要用到这套东西，于是决定还是去修改一番，更便于使用。</p>
<p>这个文章就主要讲一下修改过程，顺便说一下codesmith的简单语法。</p>
<p>先说一下操作步骤：</p>
<p>把模板的文件夹扔到codesmith模板文件的路径下，接着打开Codesmith，找到刚扔过去的文件夹，选择Main.cst,右键-execute-选择对应的MySQL库-选中表。<br><br>（注：codesmith连接MySQL有问题的话，<br><br>移步这里解决 <a href="http://codelover.link/2016/02/25/CodeSmith%E8%BF%9E%E6%8E%A5MySQL%E6%8A%A5%E9%94%99%E2%80%9C%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%B7%E6%B1%82%E7%9A%84%20.Net%20Framework%20Data%20Provider%E3%80%82%E5%8F%AF%E8%83%BD%E6%B2%A1%E6%9C%89%E5%AE%89%E8%A3%85%E3%80%82%E2%80%9D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">CodeSmith 连接MySQL数据库报“can’t find .net framework data provider”</a></p>
<p>如下图：<br><img src="http://7xrayk.com1.z0.glb.clouddn.com/20160228-1.png" alt="1"></p>
<p>然后点击Generate就能顺利生成model/dal/bll了。</p>
<p>生成代码结构如下：<br><img src="http://7xrayk.com1.z0.glb.clouddn.com/20160228-2.png" alt="2"></p>
<p></p><p>这样操作没什么问题，顺利生成了我们要的model/dal/bll了，然后….我懒嘛。<br>每次都要把表一个个选一次，麻不麻烦啊。然后就想了，能不能改一下模板呢。于是便开始google相关资料了。找到了几个相关文章，参考这就开始改造了。<br>先看看原来的Main.cst里面写了撒。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ CodeTemplate Language=<span class="string">"C#"</span> ResponseEncoding=<span class="string">"UTF-8"</span> </span><br><span class="line">TargetLanguage=<span class="string">"Text"</span> Src=<span class="string">""</span> Inherits=<span class="string">""</span> Debug=<span class="string">"False"</span> </span><br><span class="line">Description=<span class="string">"Template description here."</span> </span><br><span class="line"> Output=<span class="string">"None"</span>%&gt;</span><br><span class="line">&lt;%@ Register Name=<span class="string">"Models"</span> Template=<span class="string">"DBMad.Models.cst"</span> </span><br><span class="line">	MergeProperties=<span class="string">"False"</span> ExcludeProperties=<span class="string">""</span> %&gt;	</span><br><span class="line">&lt;%@ Register Name=<span class="string">"DAL"</span> Template=<span class="string">"DBMad.DAL.cst"</span> </span><br><span class="line">MergeProperties=<span class="string">"False"</span> ExcludeProperties=<span class="string">""</span> %&gt; </span><br><span class="line">&lt;%@ Register Name=<span class="string">"BLL"</span> Template=<span class="string">"DBMad.BLL.cst"</span> </span><br><span class="line">MergeProperties=<span class="string">"False"</span> ExcludeProperties=<span class="string">""</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ Property Name=<span class="string">"SourceTable"</span> </span><br><span class="line">Type=<span class="string">"SchemaExplorer.TableSchema"</span> Optional=<span class="string">"False"</span>%&gt;</span><br><span class="line">&lt;%@ Property Name=<span class="string">"RootNamespace"</span> Default=<span class="string">"Net.Itcast.CN"</span> </span><br><span class="line">Type=<span class="string">"System.String"</span> Optional=<span class="string">"False"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ Assembly Name=<span class="string">"SchemaExplorer"</span> %&gt;</span><br><span class="line">&lt;%@ Assembly Name=<span class="string">"System.Data"</span> %&gt;</span><br><span class="line">&lt;%@ Import Namespace=<span class="string">"SchemaExplorer"</span> %&gt;</span><br><span class="line">&lt;%@ Import Namespace=<span class="string">"System.Data"</span> %&gt;</span><br><span class="line">&lt;script runat=<span class="string">"template"</span>&gt;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">string</span> _outputDirectory = String.Empty;</span><br><span class="line">	[Editor(<span class="keyword">typeof</span>(System.Windows.Forms.Design.FolderNameEditor), </span><br><span class="line">	<span class="keyword">typeof</span>(System.Drawing.Design.UITypeEditor))] </span><br><span class="line">	[Description(<span class="string">"The directory to output the results to."</span>)]</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">string</span> OutputDirectory </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">get</span></span><br><span class="line">		&#123;		</span><br><span class="line">			<span class="keyword">return</span> _outputDirectory;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">set</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">value</span> != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">value</span>.EndsWith(<span class="string">"\\"</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">value</span> += <span class="string">"\\"</span>;</span><br><span class="line">		    &#125;</span><br><span class="line">			_outputDirectory = <span class="keyword">value</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这一段基本就是在声明选项以及引用命名空间，表现出来的便是我们看到的下图：</p>
<p><img src="http://7xrayk.com1.z0.glb.clouddn.com/20160228-1.png" alt="1"></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    Models model = <span class="keyword">this</span>.Create&lt;Models&gt;();</span><br><span class="line">	model.ModelsNamespace = <span class="keyword">this</span>.RootNamespace+<span class="string">".Model"</span>;</span><br><span class="line">	model.TargetTable = <span class="keyword">this</span>.SourceTable;</span><br><span class="line">	model.RenderToFile(<span class="keyword">this</span>.OutputDirectory+<span class="string">"Model/"</span>+model.GetFileName(),<span class="keyword">true</span>);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">   DAL dal = <span class="keyword">this</span>.Create&lt;DAL&gt;();</span><br><span class="line">   dal.TargetTable = <span class="keyword">this</span>.SourceTable;</span><br><span class="line">   dal.ModelsNamespace = model.ModelsNamespace;</span><br><span class="line">   dal.DALClassNameSurfix = <span class="string">"DAL"</span>;</span><br><span class="line">   dal.DALNamespace =<span class="keyword">this</span>.RootNamespace+<span class="string">".DAL"</span>;</span><br><span class="line">   dal.RenderToFile(<span class="keyword">this</span>.OutputDirectory+<span class="string">"DAL/"</span></span><br><span class="line">   +dal.GetFileName(),<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   BLL bll = <span class="keyword">this</span>.Create&lt;BLL&gt;();</span><br><span class="line">   bll.ModelsNamespace = model.ModelsNamespace;</span><br><span class="line">   bll.DALClassNameSurfix = dal.DALClassNameSurfix;</span><br><span class="line">   bll.DALNamespace = dal.DALNamespace;</span><br><span class="line">   bll.BLLClassNameSurfix = <span class="string">"BLL"</span>;</span><br><span class="line">   bll.BLLNamespace = <span class="keyword">this</span>.RootNamespace+<span class="string">".BLL"</span>;</span><br><span class="line">   bll.TargetTable = <span class="keyword">this</span>.SourceTable;</span><br><span class="line">   bll.RenderToFile(<span class="keyword">this</span>.OutputDirectory+<span class="string">"BLL/"</span></span><br><span class="line">   +bll.GetFileName(),<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   Response.Write(<span class="string">"ok,see "</span>+<span class="keyword">this</span>.OutputDirectory);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>这一段就是我们点击Generate之后执行的代码，基本功能就是调用<br>DBMad.Models.cst,DBMad.DAL.cst,DBMad.BLL.cst。<br>因为在上面声明数据源的时候，使用了SchemaExplorer.TableSchema，导致我们选择表的时候不能多选。代码如下：</p>
<p>&lt;%@ Property Name=”SourceTable” Type=”SchemaExplorer.TableSchema” Optional=”False”%&gt;</p>
<p>这样一想，这个Main.cst就是一个可以处理单表的生成模板了，我们只要自己写一个可以多选表的模板，然后循环调用这个模板去生成，不就完事了？</p>
<p>找了一下资料，发现只需要把上面的选项Type改一下，便可以多选表了。</p>
<p>如下：</p>
<p>&lt;%@ Property Name=”SourceTables” Type=”SchemaExplorer.TableSchemaCollection” Default=”” Optional=”False” Category=””%&gt; </p>
<p>整体代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ CodeTemplate Language=<span class="string">"C#"</span> ResponseEncoding=<span class="string">"UTF-8"</span> </span><br><span class="line">TargetLanguage=<span class="string">"Text"</span> Src=<span class="string">""</span> Inherits=<span class="string">""</span> Debug=<span class="string">"False"</span> </span><br><span class="line">Description=<span class="string">"Template description here."</span> Output=<span class="string">"None"</span>%&gt;</span><br><span class="line">&lt;%@ Property Name=<span class="string">"SourceTables"</span> </span><br><span class="line">Type=<span class="string">"SchemaExplorer.TableSchemaCollection"</span> Default=<span class="string">""</span> </span><br><span class="line">Optional=<span class="string">"False"</span> Category=<span class="string">""</span>%&gt; </span><br><span class="line">&lt;%@ Register Name=<span class="string">"SE"</span> Template=<span class="string">"CreatSingleTable.cst"</span> </span><br><span class="line">MergeProperties=<span class="string">"False"</span> ExcludeProperties=<span class="string">""</span> %&gt; </span><br><span class="line">&lt;%@ Property Name=<span class="string">"RootNamespace"</span> Default=<span class="string">"Net.Itcast.CN"</span> </span><br><span class="line">Type=<span class="string">"System.String"</span> Optional=<span class="string">"False"</span>%&gt;</span><br><span class="line">&lt;%@ Assembly Name=<span class="string">"SchemaExplorer"</span> %&gt; </span><br><span class="line">&lt;%@ Assembly Name=<span class="string">"System.Data"</span> %&gt;</span><br><span class="line">&lt;%@ Import Namespace=<span class="string">"SchemaExplorer"</span> %&gt; </span><br><span class="line">&lt;%@ Import Namespace=<span class="string">"System.Data"</span> %&gt; </span><br><span class="line">&lt;%@ Import Namespace=<span class="string">"System.Collections"</span> %&gt; </span><br><span class="line">&lt;script runat=<span class="string">"template"</span>&gt;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">string</span> _outputDirectory = String.Empty;</span><br><span class="line">	[Editor(<span class="keyword">typeof</span>(System.Windows.Forms.Design.FolderNameEditor), </span><br><span class="line">	<span class="keyword">typeof</span>(System.Drawing.Design.UITypeEditor))] </span><br><span class="line">	[Description(<span class="string">"The directory to output the results to."</span>)]</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">string</span> OutputDirectory </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">get</span></span><br><span class="line">		&#123;		</span><br><span class="line">			<span class="keyword">return</span> _outputDirectory;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">set</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">value</span> != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">value</span>.EndsWith(<span class="string">"\\"</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">value</span> += <span class="string">"\\"</span>;</span><br><span class="line">		    &#125;</span><br><span class="line">			_outputDirectory = <span class="keyword">value</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;% </span><br><span class="line"><span class="keyword">foreach</span>(TableSchema ts <span class="keyword">in</span> SourceTables) </span><br><span class="line">&#123; </span><br><span class="line">SE s = <span class="keyword">new</span> SE(); </span><br><span class="line">   s.SourceTable = ts; </span><br><span class="line">   s.RootNamespace = RootNamespace;</span><br><span class="line">   s.OutputDirectory = OutputDirectory;</span><br><span class="line">   s.Render(<span class="keyword">this</span>.Response); </span><br><span class="line">&#125; </span><br><span class="line">%&gt; </span><br><span class="line">&lt;script runat=<span class="string">"template"</span>&gt; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>前面一部分还是一样的声明，</p>
<p>&lt;%@ Property Name=”SourceTables” Type=”SchemaExplorer.TableSchemaCollection” Default=”” Optional=”False” Category=””%&gt; </p>
<p>这一句把选项类型修改成可多选的（既 集合）。<br>效果如下图：<br><img src="http://7xrayk.com1.z0.glb.clouddn.com/20160228-4.png" alt="3"></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line"><span class="keyword">foreach</span>(TableSchema ts <span class="keyword">in</span> SourceTables) </span><br><span class="line">&#123; </span><br><span class="line">SE s = <span class="keyword">new</span> SE(); </span><br><span class="line">   s.SourceTable = ts; </span><br><span class="line">   s.RootNamespace = RootNamespace;</span><br><span class="line">   s.OutputDirectory = OutputDirectory;</span><br><span class="line">   s.Render(<span class="keyword">this</span>.Response); </span><br><span class="line">&#125; </span><br><span class="line">%&gt; </span><br><span class="line">&lt;script runat=<span class="string">"template"</span>&gt; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这一段代码便是获取刚得到的表集合，遍历集合然后依次调用之前的单表生成模板。</p>
<p>到这里差不多已经完成了我要的效果，选择多表，实现一次生成所有的表对应的model/dal/bll。</p>
<p>这个效果基本就是我要的了，但是后来又发现，model里面的字段居然没有注释，我在建表的时候写了字段注释的呀。</p>
<p>打开model的cst文件之后发现，模板并没有做注释这个工作。<br>代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ CodeTemplate Language="C#" TargetLanguage="C#" </span><br><span class="line">Src="ToolsCodeTemplate.cs" Inherits="ToolsCodeTemplate"%&gt;</span><br><span class="line">&lt;%@ Property Name="TargetTable" Type="SchemaExplorer.TableSchema" </span><br><span class="line">Category="Context" Description="TargetTable that the object is </span><br><span class="line">based on." %&gt;</span><br><span class="line">&lt;%@ Property Name="ModelsNamespace" Default="Model" </span><br><span class="line">Type="System.String" Category="Context" Description="TargetTable </span><br><span class="line">that the object is based on." %&gt;</span><br><span class="line">&lt;%@ Assembly Name="SchemaExplorer" %&gt;</span><br><span class="line">&lt;%@ Assembly Name="System.Data" %&gt;</span><br><span class="line">&lt;%@ Import Namespace="SchemaExplorer" %&gt;</span><br><span class="line">&lt;%@ Import Namespace="System.Data" %&gt;</span><br><span class="line">&lt;% PrintHeader(); %&gt;</span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace &lt;%= ModelsNamespace %&gt;</span><br><span class="line">&#123;	</span><br><span class="line">	[Serializable()]</span><br><span class="line">	public class &lt;%= GetModelClassName() %&gt;</span><br><span class="line">	&#123;</span><br><span class="line">	    &lt;% </span><br><span class="line">		foreach (ColumnSchema column in TargetTable.Columns)</span><br><span class="line">	   &#123;</span><br><span class="line">		%&gt;</span><br><span class="line">			private &lt;%= GetPropertyType(column) %&gt;  _&lt;%= </span><br><span class="line">			GetPropertyName(column) %&gt;;			</span><br><span class="line">		&lt;%</span><br><span class="line">		&#125;</span><br><span class="line">		%&gt;</span><br><span class="line">	    </span><br><span class="line">		&lt;% </span><br><span class="line">		foreach (ColumnSchema column in TargetTable.Columns)</span><br><span class="line">		&#123;</span><br><span class="line">		%&gt;</span><br><span class="line">			public &lt;%= GetPropertyType(column) %&gt; &lt;%= </span><br><span class="line">			GetPropertyName(column) %&gt;</span><br><span class="line">			&#123;</span><br><span class="line">				 get &#123; return _&lt;%= GetPropertyName(column) %&gt;; &#125;</span><br><span class="line">	             set &#123; _&lt;%= GetPropertyName(column) %&gt; = value; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;%</span><br><span class="line">		&#125;</span><br><span class="line">		%&gt;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;script runat="template"&gt;</span><br><span class="line">public string GetModelClassName()</span><br><span class="line">&#123;</span><br><span class="line">	return GetModelClassName(TargetTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override string GetFileName()</span><br><span class="line">&#123;</span><br><span class="line">	return this.GetModelClassName(this.TargetTable) + ".cs";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>获取表中字段名使用的是GetPropertyName(column)，咦，在哪实现了这个东西呢？回去翻一下文件，哦，还有一个ToolsCodeTemplate.cs文一直没管呢。</p>
<p>果然，GetPropertyName(column)在这里。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetPropertyName</span>(<span class="params">ColumnSchema column</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> GetNameFromDBFieldName(column);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetNameFromDBFieldName</span>(<span class="params">ColumnSchema column</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> column.Name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取列名就是这么简单，那么我们对应写一个函数读取一下列注释，然后再model里面调用一下不好了。</p>
<p>又查了一下资料，</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetColumnComment</span>(<span class="params">ColumnSchema column</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> column.Description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，理论上这样是可以的…<br>然而，我想多了。倒腾了好久，这个属性值都是空的…<br>google了一圈之后发现，原来是SchemaExplorer.MySQLSchemaProvider.dll 里面压根没实现读取列注释的实现….</p>
<p>不过也有对应的解决方法：</p>
<p><a href="http://www.cnblogs.com/LonelyShadow/p/4147743.html" target="_blank" rel="external">完美解决CodeSmith无法获取MySQL表及列Description说明注释的方案</a></p>
<p>把DLL替换一下就好了。</p>
<p>最后附上模板连接:<a href="https://github.com/liguobao/CodeSmith-for-MySQL-Template" target="_blank" rel="external">CodeSmith-for-MySQL-Template</a></p>
<p>注：</p>
<ol>
<li>模板会把MySQL的表名前三个字符截取掉，建议把表明设置为tbl开头，或者自行修改模板文件。</li>
<li>想让字段注释生效记得替换SchemaExplorer.MySQLSchemaProvider.dll(替换前记得备份！)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/02/28/CodeSmith to MySQL/" data-id="cil6pb6uw0000cgunh8g2o00f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CodeSmith连接MySQL报错“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/27/CodeSmith连接MySQL报错“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法/" class="article-date">
  <time datetime="2016-02-27T09:41:40.501Z" itemprop="datePublished">2016-02-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CodeSmith/">CodeSmith</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/27/CodeSmith连接MySQL报错“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法/">CodeSmith 连接MySQL数据库报“can&#39;t find .net framework data provider”</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、下载 mysql-connector-net 安装</p>
<p><a href="https://dev.mysql.com/downloads/connector/net/6.9.html" target="_blank" rel="external">mysql-connector-net</a></p>
<p>2、mysql-connector-net 安装完毕之后，到对应的安装目录下，把对应的MySQL .NET dll拷贝到 CodeSmith的bin目录和SchemaProviders目录。</p>
<p>一般DLL所在目录是：</p>
<p>C:\Program Files (x86)\MySQL\MySQL Connector Net 6.9.8\Assemblies\v4.0</p>
<p>3、重启CodeSmith生效</p>
<p><br><br><br></p>
<p>其余解决方案：<br><br><br><a href="http://blog.csdn.net/joke01/article/details/9469515" target="_blank" rel="external">codesmith无法连接Mysql的解决方法</a></p>
<p><a href="http://www.cnblogs.com/tim190/archive/2013/01/18/2866161.html" target="_blank" rel="external">codesmith6.5连接Mysql提示“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/02/27/CodeSmith连接MySQL报错“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法/" data-id="cil6pb6ws000kcgunpz9ggkj0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-一些有用的网站" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/25/一些有用的网站/" class="article-date">
  <time datetime="2016-02-25T15:11:56.106Z" itemprop="datePublished">2016-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nothing/">nothing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/25/一些有用的网站/">一些有用的网站</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown 语法说明 (简体中文版)</a></p>
<p><a href="http://wowubuntu.com/markdown/basic.html" target="_blank" rel="external">Markdown: Basics （快速入门）</a></p>
<p><a href="http://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="external">使用GitHub和Hexo搭建免费静态Blog(本博客案例)</a></p>
<p><a href="https://www.mxgw.info/t/filename-too-long-in-git.html" target="_blank" rel="external">win下面的git客户端提示FIlename too long解决方法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/02/25/一些有用的网站/" data-id="cil6pb6w9000dcguncxstby1s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Join" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/23/Join/" class="article-date">
  <time datetime="2016-02-23T15:59:57.398Z" itemprop="datePublished">2016-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/net/">.net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/23/Join/">.NET-join用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#.NET   Join<br> 连接：内连接、外连接、左连接、右连接。<br>SQL的Join这里就不多说了，<br>今天主要是看一下LINQ的Join用法，以及Enumerable.Join()的用法。</p>
<p>Join用于连接数据，首先就是数据之间有联系咯。</p>
<p>先说Enumerable.Join()。<br>参数类型如下：<br>            public static IEnumerable<tresult> Join<touter, tinner,="" tkey,="" tresult=""><br>            (<br>                     this IEnumerable<touter> outer,<br>                    IEnumerable<tinner> inner,<br>                    Func<touter, tkey=""> outerKeySelector,<br>                    Func<tinner, tkey=""> innerKeySelector,<br>                    Func<touter, tinner,="" tresult=""> resultSelector<br>            )<br>类型参数<br>TOuter<br>第一个序列中的元素的类型。<br>TInner<br>第二个序列中的元素的类型。<br>TKey<br>键选择器函数返回的键的类型。<br>TResult<br>结果元素的类型。<br>参数<br>outer<br>类型：System.Collections.Generic.IEnumerable<touter><br>要联接的第一个序列。<br>inner<br>类型：System.Collections.Generic.IEnumerable<tinner><br>要与第一个序列联接的序列。<br>outerKeySelector<br>类型：System.Func<touter, tkey=""><br>用于从第一个序列的每个元素提取联接键的函数。<br>innerKeySelector<br>类型：System.Func<tinner, tkey=""><br>用于从第二个序列的每个元素提取联接键的函数。<br>resultSelector<br>类型：System.Func<touter, tinner,="" tresult=""><br>用于从两个匹配元素创建结果元素的函数。<br>返回值<br>类型：System.Collections.Generic.IEnumerable<tresult><br>IEnumerable&lt;T&gt; that has elements of type TResult that are obtained by performing an inner join on two sequences.” xml:space=”preserve”&gt;一个具有 TResult 类型元素的 IEnumerable<t>，这些元素是通过对两个序列执行内部联接得来的。<br>使用说明<br>在 Visual Basic 和 C# 中，可以在 IEnumerable<touter> 类型的任何对象上将此方法作为实例方法来调用。当使用实例方法语法调用此方法时，请省略第一个参数。有关详细信息，请参阅 扩展方法 (Visual Basic) 或 扩展方法（C# 编程指南）。</touter></t></tresult></touter,></tinner,></touter,></tinner></touter></touter,></tinner,></touter,></tinner></touter></touter,></tresult></p>
<p>先上一个MSDN的例子。</p>
<pre><code>     public static void JoinEx1()         
     {
       Person magnus = new Person { Name = &quot;Hedlund, Magnus&quot; };
       Pet barley = new Pet { Name = &quot;Barley&quot;, Owner = terry };
       Person terry = new Person { Name = &quot;Adams, Terry&quot; };
       Person charlotte = new Person { Name = &quot;Weiss, 
       Charlotte&quot; };
       Pet boots = new Pet { Name = &quot;Boots&quot;, Owner = terry };
       Pet whiskers = new Pet { Name = &quot;Whiskers&quot;, 
       Owner = charlotte};
       Pet daisy = new Pet { Name = &quot;Daisy&quot;, Owner = magnus };

    List&lt;Person&gt; people = new List&lt;Person&gt; 
    { magnus, terry, charlotte };
    List&lt;Pet&gt; pets = new List&lt;Pet&gt; 
    { barley, boots, whiskers, daisy };

    // Create a list of Person-Pet pairs where 
    // each element is an anonymous type that contains a
    // Pet&apos;s name and the name of the Person that owns the Pet.
    var query =
        people.Join(
                    pets,//需要Join的另一个数据源
          person =&gt; person,//自己用来比较的key， lambda 表达式
     pet =&gt; pet.Owner,//另一个数据源用来比较的key， lambda 表达式
(person, pet) =&gt;new { OwnerName = person.Name, Pet = pet.Name } 
               //想要取出来的数据，支持匿名对象， lambda 表达式);
    foreach (var obj in query)
    {
      Console.WriteLine( &quot;{0} - {1}&quot;,obj.OwnerName,obj.Pet);
    }
}
</code></pre><p> LINQ的Join<br>同样是上面的数据，如果换成LINQ的Join，写法如下：<br>            var query = from person in people // 第一个数据源<br>                      join pet in pets            //第二个数据源<br>                      on person equals pet.Owner  //Join条件<br>                      select  new { OwnerName = person.Name, Pet = pet.Name };<br>                      //要到得到的数据。</p>
<p>上面两种写法得到的结果都是内链接结果，至于左连接、右连接、外连接….<br>等我下次有心情再更新吧，再不走家里的键盘又要坏了。 </p>
<p>一些资料链接：<br><a href="https://msdn.microsoft.com/zh-cn/library/bb311040.aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/bb311040.aspx</a><br><a href="https://msdn.microsoft.com/zh-cn/library/bb534675%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/bb534675%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396</a><br><a href="http://www.cnblogs.com/Ivony/archive/2008/08/18/1270555.html" target="_blank" rel="external">http://www.cnblogs.com/Ivony/archive/2008/08/18/1270555.html</a><br><a href="http://www.cnblogs.com/Ivony/archive/2008/08/28/1278643.html" target="_blank" rel="external">http://www.cnblogs.com/Ivony/archive/2008/08/28/1278643.html</a><br><a href="http://www.cnblogs.com/Ivony/archive/2008/10/14/1309807.html" target="_blank" rel="external">http://www.cnblogs.com/Ivony/archive/2008/10/14/1309807.html</a> ; </p>
<p>LINQ GroupJoin 实现左连接<br>var queryGroup = from person in people // 第一个数据源<br>                                join pet in pets //第二个数据源<br>                                on person equals pet.Owner into ps //加了into,华丽变身GroupJoin<br>                                select new { OwnerName = person.Name, Pet = ps }; //要到得到的数据。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/02/23/Join/" data-id="cil6pb6wk000icgunpo1zgfd8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-技巧避免修改绑定变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/23/技巧避免修改绑定变量/" class="article-date">
  <time datetime="2016-02-23T15:59:52.750Z" itemprop="datePublished">2016-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/net/">.net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/23/技巧避免修改绑定变量/">.NET-lmabda避免修改绑定变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先看一段代码</p>
<pre><code>#region test1 闭包

public static void test1()
{
    int index = 0;
    Func&lt;IEnumerable&lt;int&gt;&gt; sequence =()=&gt;GetEnumrableInt(index);

    index = 20;
    foreach(int n in sequence())
        Console.WriteLine(n);

    Console.WriteLine(&quot;Done&quot;);

    index = 100;
    foreach (int n in sequence())
        Console.WriteLine(n);
}


public static IEnumerable&lt;int&gt; GetEnumrableInt(int index)
{
    List&lt;int&gt; l = new List&lt;int&gt;();
    for(int i=index;i&lt;index+30;i++)
    {
        l.Add(i);
    }
    return l;
}

#endregion
</code></pre><p>上面一坨代码演示了在闭包中使用了外部变量，随即又在外部修改了这些变量的情况，得到的结果是输出了20-50的数，然后又输出了100-130之间的数。这种行为有点诡异，但是确实有存在的意义…(书本这样说的，我到觉得很少会用到。)</p>
<p>为了将查询表达式转换成可执行代码，C#编译器做了很多工作。一般而言，C#编译器将查询和lambda表达式转换成 “静态委托”、”实例委托” 或 “闭包”。编译器将根据lambda表达式中的代码选择一种实现方式。选择哪种方式依赖于lambda表达式的主体（body）。这看上去似乎是一些语言上的实现细节，但它却会显著地影响到我们的代码。编译器选择何种实现将可能导致diamante行为发生微妙的变化。</p>
<p>并不是任何的lambda表达式都会生成同样结构的代码。</p>
<p>对于编译器来说，最简单的一种行为是为以下形式的代码生成委托。  </p>
<pre><code>//我们的lambda表达式
public static void test2()
{
    int[] someNum = {0,1,2,3,4,5,6,7,8,9,10 };

    IEnumerable&lt;int&gt; ans = from n in someNum
                           select n * n;

    foreach (int i in ans)
        Console.WriteLine(i);

}
</code></pre><p>编译器将使用静态委托来实现n*n的lambda表达式，其为上面代码生成的代码如下：</p>
<pre><code> //编译器为我们的lambda生成的代码
#region 等价于 test2()
private static int HiddenFunc(int n)
{
    return n * n;
}

//静态委托
private static Func&lt;int, int&gt; HiddenDelegate;

public void test2_1()
{

    int[] someNum = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    if(HiddenDelegate==null)
    {
        HiddenDelegate = new Func&lt;int, int&gt;(HiddenFunc);
    }
    IEnumerable&lt;int&gt; ans = someNum.Select&lt;int, int&gt;(HiddenDelegate);

  foreach(int i in ans)
      Console.WriteLine(i);

}
#endregion
</code></pre><p>这个lambda表达式主体部分并没有访问任何的实例变量或者局部变量。lambda表达式仅仅访问了它的参数。对于这种情况，C#编译器将创建一个静态方法，作为委托的目标。这也是编译器执行的最简单的一种处理方式。若表达式可以通过私有的静态方法实现，那么编译器将生成该私有的静态方法以及相对应的委托定义。对于上面的代码例子中的情况以及仅访问了静态变量的表达式，编译器都会采用这样的方案。</p>
<p>接下来介绍另一种较为简单的情况：<br>lambda表达式需要访问类型的实例变量，但无需访问外层方法中的局部变量。</p>
<pre><code>public class ModFilter
{
    private readonly int modules;

    public ModFilter(int mod)
    {
        modules = mod;
    }


    public IEnumerable&lt;int&gt; FindValues(IEnumerable&lt;int&gt; sequence)
    {

        return from n in sequence
               where n % modules == 0 //新添加的表达式
               select n * n;  //和前面的例子是一样的
    }
}
</code></pre><p>/* </p>
<p>在这种情况下，编译器将为表达式创建一个实例方法来包装该委托。<br>其基本概念和前一种情况一致，只是这里使用了实例方法，以便读取并修改当前对象的状态。<br>与静态委托的例子一样，这里编译器将把lambda表达式转换成我们熟悉的代码。其中包含委托的定义以及方法调用。<br>如下：</p>
<p>*/</p>
<pre><code>public class ModFilter_Other
{
    private readonly int modules;


    //实例方法
    private bool WhereClause(int n)
    {
        return ((n%this.modules) ==0);
    }


    private static int SelectClause(int n)
    {
        return n * n;
    }

    private static Func&lt;int, int&gt; SelectDelegate;




    public ModFilter_Other(int mod)
    {
        modules = mod;
    }


    public IEnumerable&lt;int&gt; FindValues(IEnumerable&lt;int&gt; sequence)
    {
        if(SelectDelegate==null)
        {
            SelectDelegate = new Func&lt;int, int&gt;(SelectClause);
        }

        return sequence.Where&lt;int&gt;(
            new Func&lt;int, bool&gt;(this.WhereClause)).
            Select&lt;int, int&gt;(SelectClause);
    }
}
</code></pre><p>概括来说便是：lambda表达式中的代码访问了对象实例中的成员变量，那么编译器将生成实例方法来表示lambda表达式中的代码。其实这并没有什么奇特之处——编译器省去了我们的一些代码输入工作，代码也变得整洁很多，本质来说这还是普通的方法调用。</p>
<p>不过若是lambda表达式中访问到了外部方法中的局部变量或者方法参数，那么编译器将帮你完成很多工作。</p>
<p>这里会用到闭包。编译器将生成一个私有的嵌套类型，以便为局部变量实现闭包。</p>
<p>局部变量必须传入到实现了lambda表达式主体部分的委托里。</p>
<p>此外，所有由该lambda表达式执行的对这些局部变量所作的修改都必须能够在外部访问到。</p>
<p>当然，代码中内层和外层中共享的可能不止有一个变量，也可能不止一个的查询表达式。</p>
<p>我们来修改一下该实例方法，让其访问一个局部变量。</p>
<pre><code>public class ModFilter
{
      private readonly int modules;

      public ModFilter(int mod)
      {
          modules = mod;
      }


      public IEnumerable&lt;int&gt; FindValues(IEnumerable&lt;int&gt; sequence)
      {
          int numValues = 0;

          return from n in sequence
                 where n % modules == 0 //新添加的表达式
                 select n * n / ++ numValues; //访问局部变量
      }
}
</code></pre><p>注意，select字句需要访问numValues这个局部变量。编译器为了创建这个闭包，需要使用嵌套类型来实现你所需要的行为。下面展示的是编译器为你生成的代码。</p>
<pre><code>  public class ModFilter
 {
    private sealed class Closure
    {
        public ModFilter outer;

        public int numValues;

        public int SelectClause(int n)
        {
            return ((n * n) / ++this.numValues);
        }
    }



    private readonly int modules;


    //实例方法
    private bool WhereClause(int n)
    {
        return ((n % this.modules) == 0);
    }

    public ModFilter(int mod)
    {
        modules = mod;
    }


    public IEnumerable&lt;int&gt; FindValues(IEnumerable&lt;int&gt; sequence)
    {
        Closure c = new Closure();
        c.outer = this;
        c.numValues = 0;

        return sequence.Where&lt;int&gt;(
            new Func&lt;int, bool&gt;(this.WhereClause)).
            Select&lt;int, int&gt;(c.SelectClause);
    }
}
</code></pre><p>在上面这段代码中，编译器专门创建了一个嵌套类，用来容纳所有将在lambda表达式中访问或修改的变量。实际上，这些局部变量将完全被嵌套类的字段所代替。lambda表达式内部的代码以及表达式外部(但仍在当前方法内)的代码访问的均是同一个字段，lambda表达式中的逻辑也被编译成了内部类的一个方法。</p>
<p>对于lambda表达式中将要用到的外部方法的参数，编译器也会以对待局部变量的方式实现：编译器将这些参数复制到表示该闭包的嵌套类中。</p>
<p>回到最开始的那个示例，这是我们应该可以理解这种看似怪异的行为了。变量index在传入闭包后，但在查询开始执行前曾被外部代码修改。也就是说，你修改了闭包的内部状态，然后还期待其能够回到从前的状态开始执行，显然这是不可能实现的。</p>
<p>考虑到延迟执行中的交互以及编译器实现闭包的方式，修改查询与外部代码之间绑定的变量将可能会引发错误的行为。<br>因此，我们应该尽量避免在方法中修改哪些将要传入到闭包中，并将在闭包中使用的变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codelover.link/2016/02/23/技巧避免修改绑定变量/" data-id="cil6pb6vw0006cgunvpyq29z0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/net/">.net</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CodeSmith/">CodeSmith</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GC/">GC</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nothing/">nothing</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/02/28/CodeSmith to MySQL/">CodeSmith for MySQL template</a>
          </li>
        
          <li>
            <a href="/2016/02/27/CodeSmith连接MySQL报错“找不到请求的 .Net Framework Data Provider。可能没有安装。”解决方法/">CodeSmith 连接MySQL数据库报“can&#39;t find .net framework data provider”</a>
          </li>
        
          <li>
            <a href="/2016/02/25/一些有用的网站/">一些有用的网站</a>
          </li>
        
          <li>
            <a href="/2016/02/23/Join/">.NET-join用法</a>
          </li>
        
          <li>
            <a href="/2016/02/23/技巧避免修改绑定变量/">.NET-lmabda避免修改绑定变量</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 李国宝<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>